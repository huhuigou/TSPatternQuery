<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Joshua Anthony Marsh" />

<meta name="date" content="2016-08-13" />

<title>A Time Series Pattern Query Tool Using PIPs and Hybrid Template-Ruleset Matching</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/default.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>

<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 66px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 71px;
  margin-top: -71px;
}

.section h2 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h3 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h4 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h5 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h6 {
  padding-top: 71px;
  margin-top: -71px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.9em;
  padding-left: 5px;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">TSPatternQuery Vignette</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">A Time Series Pattern Query Tool Using PIPs and Hybrid Template-Ruleset Matching</h1>
<h4 class="author"><em>Joshua Anthony Marsh</em></h4>
<h4 class="date"><em>2016-08-13</em></h4>

</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The Time Series Pattern Query Tool (henceforth referred to as the “TSPatternQuery” for short) is meant for quick exploration of time series patterns, and is designed to be usable by individuals of varying skill. This package can be viewed as an implementation of the “real time hybrid pattern matching scheme” presented in <span class="citation">(Z. Zhang et al. 2010)</span>. In short, this is a sliding window algorithm. Important points are identified within the window at each offset. They are then compared to a template of the desired pattern using spearman’s rho as a similarity measure. Additional rules provided to the function may be used to increase accuracy, or to short circuit the algorithm in order to increase speed.</p>
<p>The rest of this document will be laid out as follows. The first section will go into further detail explaining the underlying algorithm. The second section will present the different functions made available through the TSPatternQuery. This section will also briefly mention the CreateCustomTimeSeries function that has been provided to help the user in creating pattern templates. The last section will discuss best practices and provide examples.</p>
</div>
<div id="algorithm" class="section level1">
<h1>Algorithm</h1>
<p>The TSPatternQuery matching algorithm takes as its input a time series (the data), a pattern represented as a second shorter time series, and (optionally) some additional rules that help describe the desired pattern. These rules are contained within a <em>distinctive feature</em> function and a <em>ruleset</em> function. Additional inputs may be used to specify the length of the sliding window and the spearman rho threshold used for template matching, however these are less critical to understanding the algorithm, and will be discussed in the next section.</p>
<ol style="list-style-type: decimal">
<li><p>At a given offset of the sliding window, the first step is identifying all of the points within the window. Note that the window length is defined in seconds, not number of points.</p></li>
<li><p>This subset of the overall time series is then checked against the rules contained within the <em>distinctive feature</em> function. If it does not match the <em>distinctive feature</em>, the window moves by one point and matching starts over.</p></li>
<li><p>If the points within the window are found to match the <em>distinctive feature</em> and there are at least as many points within the window as their are in the pattern template, then “perceptually important points” (PIPs) are identified. PIPs are points that are likely to be important in forming the shape of any patterns within the data. TSPatternQuery uses the perpendicular distance method for PIP identification. Refer to <span class="citation">(Fu et al. 2007)</span> for more information on PIPs. The number of PIPs identified is equal to the number of points that make up the pattern template. <strong>It is important that the endpoints of the pattern are estimates of the time series before and after the pattern has occurred.</strong> This is because the PIP identification algorithm always identifies the first and last points of each window as PIPs. Since window length is meant to be longer than the length of the pattern, this generally results in the PIP endpoints not actually being part of the pattern itself.</p></li>
</ol>
<p><strong>Note that PIP identification is a highly complex algorithm, meaning that it is very slow.</strong> The purpose of the <em>distinctive feature</em> function is to stop the algorithm before it reaches PIP identification, thus making it run faster. See below for an example of PIPs identification.</p>
<pre class="r"><code>head.and.shoulders &lt;-   CreateCustomTimeSeries(
     c(1, 3, 2, 4, 4, 7, 3, 3.1, 5.5, 10, 9.8, 9.9, 6, 4, 6.5, 6, 5.8, 1),
     sample(7:13, 17, replace = T)
  )

plot(head.and.shoulders, main = &quot;Raw Time Series&quot;)

plot( GetPIPs(head.and.shoulders, 7), main = &quot;PIPs&quot; )</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" width="50%" /><img src="index_files/figure-html/unnamed-chunk-2-2.png" width="50%" /></p>
<ol start="4" style="list-style-type: decimal">
<li><p>PIPs are then compared to the pattern template using Spearman’s rank correlation coefficient. If Spearman’s rho is below a certain threshold, then the window moves to the next offset and matching starts over. Spearman’s rho works by ranking the values within the two sequences and then calculating the correlation between said ranks. Therefore, actual values do not matter during template matching, only their ranks relative to one another. For example, a pattern with values [15, 20, 25] will be ranked [1,2,3] and will have a Spearman’s rho of 1 when compared with any other sequence of numbers that are ranked [1,2,3].</p></li>
<li><p>If the Spearman’s rho is above the threshold, the window and pips are then checked against rules contained within the <em>ruleset</em> function. If the window and pips satisfy the <em>ruleset</em>, then the window is counted as a match. The ruleset is intended to hold rules that are higher complexity and therefore run more slowly. The purpose of the ruleset is to improve accuracy (as opposed to speed).</p></li>
</ol>
<p>See <span class="citation">(Z. Zhang et al. 2010)</span> for a more detailed description of the hybrid matching algorithm that TSPatternQuery is based on. The only significant difference is the addition of <em>distinctive feature</em> prior to PIP identification and template matching.</p>
</div>
<div id="functions" class="section level1">
<h1>Functions</h1>
<div id="query" class="section level2">
<h2>Query</h2>
<p>The Query function is the main interface to TSPatternQuery.</p>
<pre class="r"><code>Query &lt;- function(timeseries,
                  pattern.template,
                  distinctive.feature,
                  ruleset,
                  window.length = 1.2*GetTimeLength(pattern.template),
                  spearmans.rho.threshold = 0.7,
                  return.matched.patterns = FALSE
                  ) </code></pre>
<div id="timeseries" class="section level3">
<h3><em>timeseries</em></h3>
<p><em>timeseries</em> is the data being queried (i.e. the time series that may or may not contain the pattern being searched for). It should be an xts time series object. <em>timeseries</em> can be of any length, and may be regular or irregular (i.e. time intervals betwen points do not have to be of the same length).</p>
</div>
<div id="pattern.template" class="section level3">
<h3><em>pattern.template</em></h3>
<p>The <em>pattern.template</em> is an xts time series that serves as a representation of the pattern being searched for. It should be the same length (in seconds) as the pattern is estimated to be, and consist of the minimum number of points necessary to create the pattern’s shape. The first and last points in pattern.template (the endpoints) must be estimations of the time series BEFORE and AFTER the pattern has occured, otherwise it will liekly not match. For example, if the time series is normally constrained between 1 and -1, but the pattern contains points outside of this range, then a good value for the <em>pattern.template</em> endpoints would likely be 0.5.</p>
<p>The TSPatternQuery algoirhtm does not read times as absolute values. It only considers the time intervals (in seconds) between points. Thus, using a <em>pattern.template</em> with times/dates that are far removed from the timeseries data is perfectly acceptable. In other words, a <em>pattern.template</em> with timestamps from 2016 will still match data from 1990, so long as the shape is sufficiently similar.</p>
<p>Similarly, actual values do not matter on the y-axis (only their ranks) because template matching uses Spearman’s rho. See part 4 of the algorithm in section 2 for more information.</p>
<p>See <span class="citation">(Fu et al. 2007)</span> and <span class="citation">(Z. Zhang et al. 2010)</span> for more on template matching.</p>
</div>
<div id="distinctive.feature" class="section level3">
<h3><em>distinctive.feature</em></h3>
<p>The <em>distincitve.feature</em> parameter accepts a function containing rules for ruleset based matching. It should accept one parameter, which will contain the current window in xts format.</p>
<pre class="r"><code>distinctive.feature &lt;- function(window){
  
  Window.Matches.Distinctive.Feature &lt;- #Some Expression
    
  if( Window.Matches.Distinctive.Feature ){
    return(TRUE)
  }
  else{
    return(FALSE)
  }
}</code></pre>
<p>This function is run PRIOR to PIP identification and template based matching. If the current window does not contain match the <em>distinctive.feature</em>, then the algorithm will move on to the next window with identifying PIPs. Proper use of the <em>distinictive.feature</em> parameter can signficantly decrease the time it takes for the algorithm to run, since it prevents the slow GetPIPs function from being called.</p>
<p>Errors originating from the user-defined <em>distinctive.feature</em> function will simply cause the window to move to the next offset, having not found a match. This is as opposed to causing the Query function to crash, and is done for the following reasons:</p>
<ol style="list-style-type: decimal">
<li>To encourage the use of short, low-complexity functions.</li>
<li>There is no gaurantee that enough data points have been found within the window to be able to index specific points (e.g. window[[4]] would be out of bounds for a window containing only 3 points) and it is assumed that many R users are not familiar with error handling. Instructing users that errors in their function will be counted as Match = FALSE has been chosen as a more user friendly alternative to requiring that users learn R’s TryCatch syntax.</li>
</ol>
<p>Users are strongly recommended to test their <em>distinctive.feature</em> functions before using them with a large data set. See the Best Practices section below for more info on how to test these functions.</p>
<p>This is similar to ruleset matching as discussed in <span class="citation">(Fu et al. 2007)</span> and <span class="citation">(Z. Zhang et al. 2010)</span>, however, with an emphasis on improving speed rather than accuracy.</p>
</div>
<div id="ruleset" class="section level3">
<h3><em>ruleset</em></h3>
<p>The <em>ruleset</em> parameter accepts a function containing rules for ruleset based matching. It should accept two parameters, which will contain the raw window and PIPs from said window respectively (both in xts format).</p>
<pre class="r"><code>ruleset &lt;- function(window, pips){}</code></pre>
<p>This function is run AFTER PIP identification and template based matching. Unlike the <em>distinctive.feature</em> parameter, errors originating from this function WILL cause Query to crash. This is done for because <em>ruleset</em> is considered a more advanced feature than <em>distinctive.feature</em> since it is meant to contain higher complexity rules. Therefore users are expected to employ proper error handling within their code.</p>
<p>Users are strongly recommended to test their <em>ruleset</em> functions before using them with a large data set. See the Best Practices section below for more info on how to test these functions.</p>
<p>See <span class="citation">(Fu et al. 2007)</span> and <span class="citation">(Z. Zhang et al. 2010)</span> for ruleset matching.</p>
</div>
<div id="window.length" class="section level3">
<h3><em>window.length</em></h3>
<p>The <em>window.length</em> parameter is a numeric that sets the length of the sliding window in seconds. It should be slightly longer than the pattern is expected to be. This parameter defaults to 1.2 times the length of the pattern.template (in seconds).</p>
<pre class="r"><code>window.length = 1.2*GetLengthInSeconds(pattern.template)</code></pre>
<p>Special attention should be paid to ensuring that the <em>window.length</em> is reasonable. If the <em>window.length</em> is too small, the pattern will not fit inside of it. If the <em>window.length</em> is too long, it is possible that the algorithm will not find the correct PIPs.</p>
<p><em>window.length</em> is the most sensitive parameter as it can greatly effect the PIPs that are identified. Adjusting the window length is a good first step to try when Query is not finding expected patterns.</p>
</div>
<div id="spearmans.rho.threshold" class="section level3">
<h3><em>spearmans.rho.threshold</em></h3>
<p><em>spearmans.rho.threshold</em> is the threshold used to define a match between the PIPs identified in the current window and the <em>pattern.template</em>. It is set to 0.7 by default. Note that this applies to template matching only.</p>
<pre class="r"><code>spearmans.rho.threshold = 0.7</code></pre>
<p>A low <em>spearmans.rho.threshold</em> will cause the algorithm to be very permissive in what it considers a match. A high <em>spearmans.rho.threshold</em> will cause the algorithm to be more strict.</p>
</div>
<div id="return.matched.patterns" class="section level3">
<h3><em>return.matched.patterns</em></h3>
<p><em>return.matched.patterns</em> acts as a flag. If TRUE, Query will return a list of matched windows. If FALSE, Query will return a data.frame containing the number of matches found.</p>
<pre class="r"><code>return.matched.patterns = FALSE</code></pre>
<p><em>return.matched.patterns</em> is set to false by default</p>
</div>
</div>
<div id="createcustomtimeseries" class="section level2">
<h2>CreateCustomTimeSeries</h2>
<p>The CreateCustomTimeSeries function has been provided to aid the user in creating pattern templates. It may also be used to easily create xts time series for the purpose of testing <em>distinctive.feature</em> and <em>ruleset</em> functions. CreateCustomTimeSeries takes two parameters. The first is a vector of values for the time series (i.e. the y axis values). The second is a vector of time intervals (in seconds).</p>
<pre class="r"><code>CreateCustomTimeSeries &lt;- function(values, 
                                   intervals
                                   )</code></pre>
<div id="values" class="section level3">
<h3><em>values</em></h3>
<p><em>values</em> should be a vector of (y-axis) values for the time series.</p>
</div>
<div id="intervals" class="section level3">
<h3><em>intervals</em></h3>
<p><em>intervals</em> is a vector of time intervals (in seconds). When creating a time series to act as a pattern template, the sum of the intervals should be equal to the expected length of the pattern. For example, if the pattern is expected to occur in 15 seconds on average, <code>c(3,3,3,3,3)</code> would be an appropriate intervals vector.</p>
<p>The length of the intervals vector must be 1 less than that of the values vector If <code>values &lt;- c(1,2,3)</code> and <code>intervals &lt;- c(5,6)</code>, then the interval between 1 and 2 will be 5 seconds, and the interval between 2 and 3 will be 6 seconds. The point is set as the current time.</p>
</div>
</div>
<div id="getwindowvariancepdf" class="section level2">
<h2>GetWindowVariancePDF</h2>
<p>GetWindowVariancePDF calculates the probability density function of variances in a given time series for each offset of a given window length. <strong>The window length in GetWindowVariancePDF is in number of points, NOT seconds.</strong> The number of points should be set to slightly larger than the number of points in the pattern. A good rule of thumb would be to use around 1.1 - 1.2 times the number of points for GetWindowVariancePDF as there are in the pattern, depending on how many extra points are expected to be picked up by the sliding window in the Query function. GetWindowVariancePDF returns a list containing (1) a numeric which represents the variance with the highest probability, (2) the density function (approxfun of the density object), and (3) the density object as calculated using R’s built in density() function.</p>
<pre class="r"><code>GetWindowVariancePDF &lt;- function(timeseries, window.length)</code></pre>
<div id="timeseries-1" class="section level3">
<h3><em>timeseries</em></h3>
<p>The time series which will be scanned using a sliding window to find the variance of points within the window at each offset.</p>
</div>
<div id="window.length-1" class="section level3">
<h3><em>window.length</em></h3>
<p>The window length of the sliding window.</p>
</div>
</div>
<div id="getpips" class="section level2">
<h2>GetPIPs</h2>
<p>Perceptually important points (PIPs) are points that have been identified as perceptually important for the formation of patterns within a time series. GetPIPs is used by the Query function to identify PIPs within the sliding window at each offset. The function has been made available for users to call in order to test their curstom pattern templates.</p>
<p>GetPIPs uses the perpendicular distance method of PIP identification. It begins by assigning the endpoints of the <em>timeseries</em> as the first two PIPs. It then finds the point between those two PIPs with the greatest perpendicular distance to the line connecting said PIPs. It repeats this process until the desired number of PIPs have been identified.</p>
<p>See <span class="citation">(Fu et al. 2007)</span> for more information on PIPs.</p>
<pre class="r"><code>GetPIPs &lt;- function(timeseries, num.pips) </code></pre>
<div id="timeseries-2" class="section level3">
<h3><em>timeseries</em></h3>
<p>The time series within which PIPs will be identified. Remember that the first two PIPs will always be the first and last point of this time series.</p>
</div>
<div id="num.pips" class="section level3">
<h3><em>num.pips</em></h3>
<p>The number of PIPs to identify.</p>
</div>
</div>
<div id="matchpattern" class="section level2">
<h2>MatchPattern</h2>
<p>This is the function used by Query to check whether two time series (i.e. a window and pattern template) match based on the template matching method. This is done by calculating the Spearman’s rho between the two time series, and returning true if it is above a threshold. The threshold is set to 0.7 by default</p>
<p>The MatchPattern function is made available for users to use in testing their pattern templates.</p>
<pre class="r"><code>MatchPattern &lt;- function(timeseries, pattern.template, threshold=0.7)</code></pre>
<div id="timeseries-3" class="section level3">
<h3><em>timeseries</em></h3>
<p>The timeseries that will be check against the pattern to see if they match.</p>
</div>
<div id="pattern.template-1" class="section level3">
<h3><em>pattern.template</em></h3>
<p>The pattern template that will be checked against. <em>timeseries</em> for a match.</p>
</div>
<div id="threshold" class="section level3">
<h3><em>threshold</em></h3>
<p>The Spearman’s rho threshold, above which <em>timeseries</em> and <em>pattern.template</em> will be counted as matching (the function will return TRUE). This is set to 0.7 by default, and should be between 0 and 1. Increasing this value will cause the function to be more strict in what it considers to be a match. Decreasing it will cause the function to be more permissive.</p>
</div>
</div>
</div>
<div id="best-practices" class="section level1">
<h1>Best Practices</h1>
<div id="testing-user-defined-parameters" class="section level2">
<h2>Testing User Defined Parameters</h2>
<p>While TSPatternQuery is meant for quick exploration of patterns within time series data, pattern templates, distinctive features, and rulesets should still be tested to verify that they behave as expected. The amount of effort expended on testing may differ depending on the desired verifiability of the results.</p>
<p>The simplest way in which to test these things is by using the R console to check that they return the correct results under each possible condition that they may encounter. Several conditions that all ruleset and distinctive feature functions should be tested for include:</p>
<ol style="list-style-type: decimal">
<li>Does it return TRUE when its supposed to</li>
<li>Does it return FALSE when its supposed to</li>
<li>Are there any situations in which it might return NA? This will be counted as FALSE by the algorithm. Is this desireable?</li>
<li>Are there any situations in which it might throw an Error? This will be counted as FALSE by the algorithm. Is this desireable?</li>
</ol>
<p>More rigorous testing may be performed using RUnit or testthat packages. These facilitate the creation of automated scripts containing the same sort of tests that one might type into the console, as described above. The advantage of this sort of testing is that it is automated, and may thus be run each time something is added or changed. This reduces the liklihood of things breaking unexpectedly.</p>
<p>Note that the CreateCustomTimeSeries function may be used, not only to create pattern templates, but also to create time series for testing purposes.</p>
</div>
<div id="simple-distinctive-features" class="section level2">
<h2>Simple Distinctive Features</h2>
<p>Below are several functions that may be passed to the <em>distinctive.feature</em> parameter. Remember that the aim of <em>distinctive.feature</em> is to reduce running time by finding false matches early in the algorithms exectution (i.e. before PIP identification). The first function will include a worked example.</p>
<div id="exclusion-based-on-variance---a-worked-example" class="section level3">
<h3>Exclusion Based on Variance - A Worked Example</h3>
<p>If the variance of the pattern significantly differs from that of the surrounding time series, then excluding low (and/or high) variance segments can be an effective distinctive feature.</p>
<p>The function GetWindowVariancePDF has been included in the TSPatternQuery package in order to help determine whether exclusion based on variance is a appropriate for a given time series and window size.</p>
<p>This worked example will demonstrate querying the ts.low.var time series with the pattern.headandshoulders pattern. The GetWindowVariancePDF function will be used to find an appropriate variance to exclude. Most of the source code used in this example has been made visible for demonstration purposes. The comments above each chunk of code should be sufficient to follow along without needing to read every line of code.</p>
<p>The first step will be to define a pattern, import some data for the time series, and the these two things.</p>
<pre class="r"><code>#define pattern
pattern.headandshoulders &lt;- CreateCustomTimeSeries(
    c(0,4,2,6,2,4,0),
    c(5,5,5,5,5,5)
    )

#import time series data
ts.low.var.csv &lt;- read.csv(&quot;var-exclusion-ts.csv&quot;)
ts.low.var &lt;- xts(ts.low.var.csv[[2]], order.by = as.POSIXct(ts.low.var.csv[[1]]))

#Plot time series and pattern
plot(ts.low.var)
plot(pattern.headandshoulders)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-13-1.png" width="50%" /><img src="index_files/figure-html/unnamed-chunk-13-2.png" width="50%" /></p>
<p>Comparing the variance of the pattern to the probability density function (PDF) of the time series (see below) reveals that a significant number of windows have a lower variance than the pattern. Therefore, variance exclusion is an appropriate distinctive feature for this particular query.</p>
<pre class="r"><code>#Plot the Time Series Variance Probability Density Function (PDF)
ts.low.var.pdf &lt;- GetWindowVariancePDF(ts.low.var, window.length=8)
curve(ts.low.var.pdf$density.fun(x), 
      from= min(ts.low.var.pdf$density.points$x), 
      to=max(ts.low.var.pdf$density.points$x), 
      main=&quot;Time Series Variance \nProbability Density Function&quot;,
      ylab=&quot;Probability&quot;,
      xlab=&quot;Window Variance&quot;,
      sub=&quot;The red vertical line is the pattern variance.&quot;)

#Calculate the Pattern Variance and Add to the PDF Plot as a Vertical Red Line
pattern.var &lt;- var(pattern.headandshoulders)
abline(v=pattern.var, col=&quot;red&quot;)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-14-1.png" width="50%" style="display: block; margin: auto;" /></p>
<p>Since one or more additional points may be picked up in the same window as the pattern, it is a good idea to ensure that the variance exclusion threshold is not too close to the pattern variance. The pattern variance here is about 4.9, so a threshold of 3.5 will be used. This should still be an effective threshold based on the time series’ PDF function (above).</p>
<pre class="r"><code>#The query function finds two matches in the time series
initial.results &lt;- Query(
    ts.low.var,
    pattern.headandshoulders,
    window.length = 40,
    return.matched.patterns = TRUE
)

#Plot the two matches
plot(initial.results[[1]], main = &quot;1st Matched Window&quot;, 
     sub=paste(&quot;Variance =&quot;, var(initial.results[[1]])))
plot(initial.results[[2]], main = &quot;2nd Matched Window&quot;, 
     sub=paste(&quot;Variance =&quot;, var(initial.results[[2]])))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-15-1.png" width="50%" /><img src="index_files/figure-html/unnamed-chunk-15-2.png" width="50%" /></p>
<p>Note that the variance of the first matched window (0.5222922) is much lower than that of the second matched window (variance = 4.7704365).</p>
<p>Recording the running time of the Query function with and without an “Exclude Low Variance” distinctive feature reveals that the algorithm runs significantly faster with said distinctive feature.</p>
<pre class="r"><code>#Time the Query algorithm WITHOUT variance exclusion as a distinctive feature 
#and store the result in t.without.df
t.without.df &lt;- system.time(
  results.without &lt;- Query(
      ts.low.var,
      pattern.headandshoulders,
      window.length = 40,
      return.matched.patterns = TRUE
  )
)

#Time the Query algorithm WITH variance exclusion as a distinctive feature 
#and store the result in t.with.df
exclude.low.var &lt;- function(window){
  var.threshold &lt;- 3.5
  return(var(window)&gt;var.threshold)
}

t.with.df &lt;- system.time(
  results.with &lt;- Query(
      ts.low.var,
      pattern.headandshoulders,
      window.length = 40,
      distinctive.feature = exclude.low.var,
      return.matched.patterns = TRUE
  )
)

#Print the elapsed times
cat(&quot;Elapsed Time Without Excluding Low Variance:&quot;, t.without.df[[3]], 
    &quot;\nElapsed Time With Excluding Low Variance:&quot;, t.with.df[[3]] )</code></pre>
<pre><code>## Elapsed Time Without Excluding Low Variance: 0.53 
## Elapsed Time With Excluding Low Variance: 0.214</code></pre>
<p>Note that the previously 1st Matched Window from before no longer matches since it does not satisfy the distinctive feature of having a variance greater than 3.5. This may or may not be desireable depending on the circumstances.</p>
<pre class="r"><code>length(results.with)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>plot(results.with[[1]], main=&quot;The Only Window Returned When Variance \nExclusion was Used&quot;, 
     sub=paste(&quot;Variance =&quot;, var(results.with[[1]]) ) )</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-17-1.png" width="50%" style="display: block; margin: auto;" /></p>
</div>
<div id="increasing-or-decreasing-on-average" class="section level3">
<h3>Increasing or Decreasing (On Average)</h3>
<pre class="r"><code>increasing &lt;- function(window){
  return( mean(diff(as.vector(window))) &gt; 0 )
}

decreasing &lt;- function(window){
  return( mean(diff(as.vector(window))) &lt; 0 )
}</code></pre>
</div>
<div id="increasing-or-decreasing-every-point-is-greaterless-than-its-predecessor" class="section level3">
<h3>Increasing or Decreasing (Every point is greater/less than its predecessor)</h3>
<pre class="r"><code>increasing.monotonically &lt;- function(window){
  return(all(window == cummax(window)))
}

decreasing.monotonically &lt;- function(window){
  return(all(window == cummin(window)))
}</code></pre>
<p>See <em><a href="http://stackoverflow.com/questions/13093912/how-to-check-if-a-sequence-of-numbers-is-monotonically-increasing-or-decreasing">StackOverflow - How to check if a sequence of numbers is monotonically increasing (or decreasing)?</a></em> for more about detecting monotonically increasing or decreasing vectors using cummax and cummin.</p>
</div>
<div id="in-range" class="section level3">
<h3>In Range</h3>
<pre class="r"><code>within.range &lt;- function(window){
  ceiling &lt;- 5
  floor &lt;- -5
  return ( all(window &lt; ceiling) &amp;&amp; all(window &gt; floor))
}</code></pre>
</div>
</div>
<div id="a-note-on-rulesets" class="section level2">
<h2>A Note on Rulesets</h2>
<p>The <em>ruleset</em> parameter is meant for more complex functions than <em>distinctive.feature</em>. A good rule of thumb is if a function uses loops (especially embedded loops), or is otherwise knwon to be slow, then it should be included in <em>ruleset</em> rather than <em>distinctive.feature</em>. Functions that rely on PIPs must also go in <em>rulset</em> since PIPs are not made available to <em>distinctive.feature</em> functions.</p>
</div>
<div id="combining-rules-for-aggregated-rulesets-and-distinctive-features" class="section level2">
<h2>Combining Rules for Aggregated Rulesets and Distinctive Features</h2>
<p>Multiple functions may be passed to <em>ruleset</em> or <em>distinctive.feature</em> by wrapping them inside of a single function. The example shown here will use <em>ruleset</em> but can be applied to <em>distinctive.feature</em> so long as the component functions only use the window argument (since <em>distinctive.feature</em> does not deal with PIPs).</p>
<p>First begin by defining the functions that will make up each of the rules.</p>
<pre class="r"><code>contains.three.peaks.above.10 &lt;- function(pips){
  stopifnot(length(pips) != 7)
  
  #Assign peaks based on 7 points head and shoulders template
  possible.peak1 &lt;- pips[[2]]
  possible.peak2 &lt;- pips[[4]]
  possible.peak3 &lt;- pips[[6]]
  
  #Check that peaks are actually peaks (i.e. that they are higher than adjacent points)
  if(possible.peak1 &lt; pips[[1]] | possible.peak2 &lt; pips[[3]]) return(FALSE)
  if(possible.peak2 &lt; pips[[3]] | possible.peak2 &lt;pips[[5]]) return(FALSE)
  if(possible.peak3 &lt; pips[[5]] | possible.peak3 &lt; pips[[7]]]) return(FALSE)
  
  #Return true if peaks are higher than 10
  return(possible.peak1&gt;10 &amp;&amp; possible.peak2 &gt; 10 &amp;&amp; possible.peak3 &gt;10)
}

middle.peak.is.higher &lt;- function(pips){
  peak1 &lt;- pips[[2]]
  peak2 &lt;- pips[[4]]
  peak3 &lt;- pips[[6]]
  
  return(peak2 &gt; peak1 &amp;&amp; peak2 &gt; peak3)
}

variance.greater.than.2 &lt;- function(window){
  return(var(window)&gt;2)
}</code></pre>
<p>Then call them all from within a single “aggregate ruleset” function. The aggreate function is passed to Query as normal.</p>
<pre class="r"><code>aggregate.ruleset &lt;- function(window, pips){
  
  firstRule &lt;- contains.three.peaks.above.10(pips)
  secondRule &lt;- middle.peak.is.higher(pips)
  thirdRule &lt;- variance.greater.than.2(window)
  
  return(firstRule &amp;&amp; secondRule &amp;&amp; thirdRule)
}

Query(
    ts.low.var,
    pattern.headandshoulders,
    window.length = 40,
    ruleset = aggregate.ruleset,
    return.matched.patterns = TRUE
)</code></pre>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Fu:2007:STS:1230165.1230538">
<p>Fu, Tak-chung, Fu-lai Chung, Robert Luk, and Chak-man Ng. 2007. “Stock Time Series Pattern Matching: Template-Based Vs. Rule-Based Approaches.” <em>Eng. Appl. Artif. Intell.</em> 20 (3). Tarrytown, NY, USA: Pergamon Press, Inc.: 347–64. doi:<a href="https://doi.org/10.1016/j.engappai.2006.07.003">10.1016/j.engappai.2006.07.003</a>.</p>
</div>
<div id="ref-Zhang:2010:RTH:1862242.1862263">
<p>Zhang, Zhe, Jian Jiang, Xiaoyan Liu, Ricky Lau, Huaiqing Wang, and Rui Zhang. 2010. “A Real Time Hybrid Pattern Matching Scheme for Stock Time Series.” In <em>Proceedings of the Twenty-First Australasian Conference on Database Technologies - Volume 104</em>, 161–70. ADC ’10. Darlinghurst, Australia, Australia: Australian Computer Society, Inc. <a href="http://dl.acm.org/citation.cfm?id=1862242.1862263" class="uri">http://dl.acm.org/citation.cfm?id=1862242.1862263</a>.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
