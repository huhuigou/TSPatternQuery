---
title: "A Time Series Pattern Query Tool Using PIPs and Hybrid Template-Ruleset Matching"
author: "Joshua Anthony Marsh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A Time Series Pattern Query Tool Using PIPs and Hybrid Template-Ruleset Matching}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../bibliography.bib
---

```{r, fig.show='hide', include=FALSE}
library(TSPatternQuery)
library(xts)
library(zoo)
```
##Introduction
The Time Series Pattern Query Tool (henceforth referred to as the "TSQuery Tool" for short) is meant for quick exploration of time series patterns, and is designed to be usable by individuals of varying skill. This package can be viewed as an implementation of the "real time hybrid pattern matching scheme" presented in [@Zhang:2010:RTH:1862242.1862263]. In short, this is a sliding window algorithm. Important points are identified within the window at each offset. They are then compared to a template of the desired pattern using spearman's rho as a similarity measure. Additional rules provided to the function may be used to increase accuracy, or to short circuit the algorithm in order to increase speed.

The rest of this document will be laid out as follows. The first section will go into further detail explaining the underlying algorithm. The second section will present the Query function as the user interface of the TSQuery Tool and discuss how to use it's different parameters. This section will also briefly mention the CreateCustomTimeSeries function that has been provided to help the user in creating pattern templates. The last section will discuss best practices and present several examples that demonstrate where each parameter fits into said algorithm, and how they may be leveraged for optimal speed and accuracy.

##Algorithm

The TSQuery Tool matching algorithm takes as its input a time series (the data), a pattern represented as a second shorter time series, and (optionally) some additional rules that help describe the desired pattern. These rules are contained within a *distinctive feature* function and a *ruleset* function. Additional inputs may be used to specify the length of the sliding window and the spearman rho threshold used for template matching, however these are less critical to understanding the algorithm, and will be discussed in the next section.

At a given offset of the sliding window, the first step is identifying all of the points within the window. Note that the window length is defined in seconds, not number of points. 

This subset of the overall time series is then checked against the rules contained within the *distinctive feature* function. If it does not match the *distinctive feature*, the window moves by one point and matching starts over.

If the points within the window are found to match the *distinctive feature* and there are at least as many points within the window as their are in the pattern template, then "perceptually important points" (PIPs) are identified. PIPs are points that are likely to be structurally important in forming the shape of any patterns within the data. TSQuery Tool uses the perpendicular distance method for PIP identification. Refer to [@Fu:2007:STS:1230165.1230538] for more information on PIPs. The number of PIPs identified is equal to the number of points that make up the pattern template.

**Note that PIP identification is a highly complex algorithm, meaning that it is very slow.** The purpose of the *distinctive feature* function is to stop the algorithm before it reaches PIP identification, thus making it run faster. See below for an example of PIPs identification.

```{r, fig.show='hold', eval=TRUE, out.width='47%'}

head.and.shoulders <-   CreateCustomTimeSeries(
     c(1, 3, 2, 4, 4, 7, 3, 3.1, 5.5, 10, 9.8, 9.9, 6, 4, 6.5, 6, 5.8, 1),
     sample(7:13, 17, replace = T)
  )

plot(head.and.shoulders, main = "Raw Time Series")

plot( GetPIPs(head.and.shoulders, 7), main = "PIPs" )


```

PIPs are then compared to the pattern template using Spearman's rank correlation coefficient. If Spearman's rho is below a certain threshold, then the window moves to the next offset and matching starts over. Otherwise, the window and pips are checked against rules contained within the *ruleset* function. If they the window and pips satisfy the *ruleset*, then the window is counted as a match.

See [@Zhang:2010:RTH:1862242.1862263] for a more detailed description of the algorithm used by TSQuery Tool. The only significant difference is that TSQuery Tool's usage of *distinctive feature* prior to PIP identification and template matching.

##User Interface
###Query
The TSQuery Tool may be accessed through the following function:

```{r, fig.show='hold', eval=FALSE}
Query <- function(timeseries,
                  pattern.template,
                  distinctive.feature,
                  ruleset,
                  window.length = 1.2*GetTimeLength(pattern.template),
                  spearmans.rho.threshold = 0.7,
                  return.matched.patterns = FALSE
                  ) 
```

**timeseries**

*timeseries* is the data being queried (i.e. the time series that may or may not contain the pattern being searched for). It should be an xts time series object. *timeseries* can be of any length, and may be regular or irregular (i.e. time intervals betwen points do not have to be of the same length).

**pattern.template**

The *pattern.template* is an xts time series that serves as a representation of the pattern being searched for. It should be the same length (in seconds) as the pattern, and consist of the minimum number of points necessary to create the pattern's shape.

The TSQuery Tool algoirhtm does not read times as absolute values. It only considers the time intervals (in seconds) between points. Thus, using a *pattern.template* with times/dates that are far removed from the timeseries data is perfectly acceptable. In other words, a *pattern.template* with timestamps from 2016 will still match data from 1990, so long as the shape is sufficiently similar. 

This parameter pertains to template matching as discussed in [@Fu:2007:STS:1230165.1230538] and [@Zhang:2010:RTH:1862242.1862263].

**distinctive.feature**

The *distincitve.feature* parameter accepts a function containing rules for ruleset based matching. It should accept one parameter, which will contain the current window in xts format. 

```{r, fig.show='hold', eval=FALSE}
distinctive.feature <- function(window){}
```

This function is run BEFORE PIP identification and template based matching, and thus may short circuit the algorithm if the current window does not contain the *distinctive.feature*. Proper use of the *distinictive.feature* parameter can signficantly decrease the time it takes for the algorithm to run, since it prevents the complex GetPIPs function from being called.

Errors originating in the user-defined distinctive.feature function will simply cause the window to move to the next offset, having not found a match. This is as opposed to causing the Query function to crash, and is done for the following reasons:

1. To encourage the use of short, low-complexity functions.
2. There is no gaurantee that enough data points have been found within the window to be able to index specific points (e.g. window[[4]] would be out of bounds for a window containing only 3 points) and it is assumed that many R users are not familiar with error handling. Instructing users that errors in their function will be counted as Match = FALSE has been chosen as a more user friendly alternative to requiring that users learn R's TryCatch syntax.

Users are strongly recommended to test their distinctive.feature functions before using them with a large data set. See the Best Practices and Examples section below for more info on how to test these functions. 

This is similar to ruleset matching as discussed in [@Fu:2007:STS:1230165.1230538] and [@Zhang:2010:RTH:1862242.1862263], however, with an emphasis on improving speed rather than accuracy.

**ruleset**

The *ruleset* parameter accepts a function containing rules for ruleset based matching. It should accept two parameters, which will contain the current window and identified PIPs respectively (both in xts format).

```{r, fig.show='hold', eval=FALSE}
ruleset <- function(window, pips){}
```

This function is run AFTER PIP identification and template based matching. Unlike the *distinctive.feature* parameter, errors originating from this function WILL cause Query to crash. This is done for because *ruleset* is considered a more advanced feature than *distinctive.feature* since it is meant to contain higher complexity rules. Therefore users are expected to employ proper error handling within their code.

Users are strongly recommended to test their distinctive.feature functions before using them with a large data set. See the Best Practices and Examples section below for more info on how to test these functions. 

See [@Fu:2007:STS:1230165.1230538] and [@Zhang:2010:RTH:1862242.1862263] for ruleset matching.

**window.length**
The *window.length* parameter is a numeric that sets the length of the sliding window in seconds. This parameter defaults to 1.2 times the length of the pattern.template (again, in seconds). 

```{r, fig.show='hold', eval=FALSE}
window.length = 1.2*GetTimeLength(pattern.template)
```

Special attention should be paid to ensuring that the *window.length* is reasonable. If the *window.length* is too small, the pattern will not fit inside of it. If the *window.length* is too long, it is possible that the algorithm will not find the correct PIPs.


**spearmans.rho.threshold**

The *spearmans.rho.threshold* is the threshold used to define a match between the PIPs identified in the current window and the *pattern.template*. It is set to 0.7 by default. Note that this applies to template matching only.

```{r, fig.show='hold', eval=FALSE}
spearmans.rho.threshold = 0.7
```

A low *spearmans.rho.threshold* will cause the algorithm to be very permissive in what it considers a match. A high *spearmans.rho.threshold* will cause the algorithm to be more strict.

**return.matched.patterns**
```{r, fig.show='hold', eval=FALSE}
return.matched.patterns = FALSE
```
*return.matched.patterns* acts as a flag. If TRUE, Query will return a list of matched windows. If FALSE, Query will return a <span style="color:red">data.frame containing the number of matches found.</span>

<span style="color:red">TODO: Change this once output is finalized.</span>.

###CreateCustomTimeSeries
The CreateCustomTimeSeries function has been provided to aid the user in creating pattern templates. It may also be used to easily create xts time series for the purpose of testing *distinctive.feature* and *ruleset* functions. CreateCustomTimeSeries takes two parameters. 
The first is a vector of values for the time series (i.e. the y axis values). The second is a vector of time intervals (in seconds).
```{r, fig.show='hold', eval=FALSE}
CreateCustomTimeSeries <- function(values, 
                                   intervals
                                   )
```
The length of the intervals vector must be 1 less than that of the values vector If values <- c(1,2,3) and intervals <- c(5,6), then the interval between 1 and 2 will be 5 seconds, and the interval between 2 and 3 will be 6 seconds. The point is set as the current time.


##Best Practices and Examples

###Testing *distinctive.feature* and *ruleset* Functions
<span style="color:red"> TODO: Demonstrate creating several time series that should and should not satisfy a function and testing on that. Discuss RUnit as a more formal a rigid way to test functions, especially if they have multiple and/or complex functions and would like automated scripts to verify they still work every time they change something.<span>

Conditions to test for
1. Does it return TRUE when its supposed to
2. Does it return FALSE when its supposed to
3. Are there any situations in which it might return NA? This will be counted as FALSE by the algorithm. Is this desireable?
4. Are there any situations in which it might throw an Error? This will be counted as FALSE by the algorithm. Is this desireable?

###Simple *distinctive.feature* Examples

Below are several examples of simple functions that may be passed to the distinctive.feature parameter in order to reduce the run time of the algorithm.

**No low variance**
Checking that the variance is above a certain threshold is particularly useful when most of the time series is fairly constant, or the pattern has values that occur outisde of a reference range of some sort.
```{r, fig.show='hold', eval=FALSE}

no.low.var <- function(window){
  var.threshold <- 2
  return(var(window)>var.threshold)
}
```

```{r, eval=TRUE, fig.align='center',fig.show='hold'}
ts.with.low.var <- CreateCustomTimeSeries(
     c(sample(-2.0:2.0, 50, replace = T),
     c(-6, 5, -2, 7, -2, 5, -6),
     sample(-2.0:2.0, 50, replace=T)),
     seq(from=5,to=5, length.out = 106)
)
plot(ts.with.low.var)
```

```{r, eval=TRUE,fig.show='hold', out.width='47%'}
#Selet the threshold by finding the variance of a section where the pattern is not present
threshold <- var(ts.with.low.var[1:50])
no.low.var <- function(window){
  return(var(window)>threshold)
}

pattern <- CreateCustomTimeSeries(
    c(1, 7, 5, 9, 5, 7, 1),
    seq(from=5,to=5,length.out = 6)
)
plot(pattern, main="Pattern Template")

plot(
  Query(
    ts.with.low.var,
    pattern,
    window.length = 40,
    distinctive.feature = no.low.var,
    
    return.matched.patterns = T
  )[[1]], 
  main="Window Matching Pattern"
)
```

**Increasing (On Average)**
```{r, fig.show='hold', eval=FALSE}

increasing <- function(window){
  return( mean(diff(as.vector(window))) > 0 )
}
```

**Increasing (Every point is greater than its predecessor)**
```{r, fig.show='hold', eval=FALSE}

increasing.monotonically <- function(window){
  return(all(window == cummax(window)))
}
```
TODO: provide link to stack overflow
**Decreasing (On Average)**
```{r, fig.show='hold', eval=FALSE}

decreasing <- function(window){
  return( mean(diff(as.vector(window))) < 0 )
}
```

**Decreasing (Every point is less than its predecessor)**
```{r, fig.show='hold', eval=FALSE}

decreasing.monotonically <- function(window){
  return(all(window == cummin(window)))
}
```
TODO: provide link to stack overflow

```{r, fig.show='hold', eval=FALSE}
within.range <- function(window){
  ceiling <- 5
  floor <- -5
  
  return ( all(window < ceiling) && all(window > floor))
}
```

###Simple *ruleset* Examples

###Finding Optimal *window.length*

###Finding Optimal *spearmans.rho.threshold*

##References
