---
title: "A Time Series Pattern Query Tool Using PIPs and Hybrid Template-Ruleset Matching"
author: "Joshua Anthony Marsh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A Time Series Pattern Query Tool Using PIPs and Hybrid Template-Ruleset Matching}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../bibliography.bib
---

##Introduction
The Time Series Pattern Query Tool (henceforth referred to as the "TSQuery Tool" for short) is meant for quick exploration of time series data patterns, and is designed to be usable by individuals of varying skill. This package can be viewed as an implementation of the "real time hybrid pattern matching scheme" presented in [@Zhang:2010:RTH:1862242.1862263]. In short, this is a sliding window algorithm. Important points are identified within the window at each offset. They are then compared to a template of the desired pattern using spearman's rho as a similarity measure. Additional rules provided to the function may be used to increase accuracy, or to short circuit the algorithm in order to increase speed.

The rest of this document will be laid out as follows. The first section will go into further detail explaining the underlying algorithm. The second section will present the Query function as the user interface of the TSQuery Tool and discuss how to use it's different parameters. This section will also briefly mention the CreateCustomTimeSeries function that has been provided to help the user in creating pattern templates. The last section will discuss best practices and present several examples that demonstrate where each parameter fits into said algorithm, and how they may be leveraged for optimal speed and accuracy.

##Algorithm
TSQuery Tool applies a sliding window to the 

Be very explicit that PIP identification is the rate-limiting part of the algorithm (i.e. it is very slow, O(n^3)).

##User Interface
###Query
The TSQuery Tool may be accessed through the following function:

```{r, fig.show='hold', eval=FALSE}
Query <- function(timeseries,
                  pattern.template,
                  distinctive.feature,
                  ruleset,
                  window.length = 1.2*GetTimeLength(pattern.template),
                  spearmans.rho.threshold = 0.7,
                  return.matched.patterns = FALSE
                  ) 
```

**timeseries**

*timeseries* is the data being queried (i.e. the time series that may or may not contain the pattern being searched for). It should be an xts time series object. *timeseries* can be of any length, and may be regular or irregular (i.e. time intervals betwen points do not have to be of the same length).

**pattern.template**

The *pattern.template* is an xts time series that serves as a representation of the pattern being searched for. It should be the same length (in seconds) as the pattern, and consist of the minimum number of points necessary to create the pattern's shape.

The TSQuery Tool algoirhtm does not read times as absolute values. It only considers the time intervals (in seconds) between points. Thus, using a *pattern.template* with times/dates that are far removed from the timeseries data is perfectly acceptable. In other words, a *pattern.template* with timestamps from 2016 will still match data from 1990, so long as the shape is sufficiently similar. 

This parameter pertains to template matching as discussed in [@Fu:2007:STS:1230165.1230538] and [@Zhang:2010:RTH:1862242.1862263].

**distinctive.feature**

The *distincitve.feature* parameter accepts a function containing rules for ruleset based matching. It should accept one parameter, which will contain the current window in xts format. 

```{r, fig.show='hold', eval=FALSE}
distinctive.feature <- function(window){}
```

This function is run BEFORE PIP identification and template based matching, and thus may short circuit the algorithm if the current window does not contain the *distinctive.feature*. Proper use of the *distinictive.feature* parameter can signficantly decrease the time it takes for the algorithm to run, since it prevents the complex GetPIPs function from being called.

Errors originating in the user-defined distinctive.feature function will simply cause the window to move to the next offset, having not found a match. This is as opposed to causing the Query function to crash, and is done for the following reasons:

1. To encourage the use of short, low-complexity functions.
2. There is no gaurantee that enough data points have been found within the window to be able to index specific points (e.g. window[[4]] would be out of bounds for a window containing only 3 points) and it is assumed that many R users are not familiar with error handling. Instructing users that errors in their function will be counted as Match = FALSE has been chosen as a more user friendly alternative to requiring that users learn R's TryCatch syntax.

Users are strongly recommended to test their distinctive.feature functions before using them with a large data set. See the Best Practices and Examples section below for more info on how to test these functions. 

This is similar to ruleset matching as discussed in [@Fu:2007:STS:1230165.1230538] and [@Zhang:2010:RTH:1862242.1862263], however, with an emphasis on improving speed rather than accuracy.

**ruleset**

The *ruleset* parameter accepts a function containing rules for ruleset based matching. It should accept two parameters, which will contain the current window and identified PIPs respectively (both in xts format).

```{r, fig.show='hold', eval=FALSE}
ruleset <- function(window, pips){}
```

This function is run AFTER PIP identification and template based matching. Unlike the *distinctive.feature* parameter, errors originating from this function WILL cause Query to crash. This is done for the following reasons:

1. *ruleset* is considered a more advanced feature than *distinctive.feature* because it is meant to contain higher complexity rules. Therefore users are expected to employ proper error handling within their code.
2. 



Explain that ruleset is considered a more advanced feature, since higher complexity rules are expected here. Thus, users using this feature are expected to know TryCatch syntax.

See [@Fu:2007:STS:1230165.1230538] and [@Zhang:2010:RTH:1862242.1862263] for ruleset matching.

**window.length**
```{r, fig.show='hold', eval=FALSE}
window.length = 1.2*GetTimeLength(pattern.template)
```

**spearmans.rho.threshold**
```{r, fig.show='hold', eval=FALSE}
spearmans.rho.threshold = 0.7
```

**return.matched.patterns**
```{r, fig.show='hold', eval=FALSE}
return.matched.patterns = FALSE
```

###CreateCustomTimeSeries
```{r, fig.show='hold', eval=FALSE}
CreateCustomTimeSeries <- function(values, 
                                   intervals
                                   )
```



##Best Practices and Examples

###Testing *distinctive.feature* and *ruleset* Functions
Demonstrate creating several time series that should and should not satisfy a function and testing on that. Discuss RUnit as a more formal a rigid way to test functions, especially if they have multiple and/or complex functions and would like automated scripts to verify they still work every time they change something.

###Simple *distinctive.feature* Examples

###Simple *ruleset* Examples

###Finding Optimal *window.length*

###Finding Optimal *spearmans.rho.threshold*




#The Vignette template (TODO: delete once finished)

Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))

#References
